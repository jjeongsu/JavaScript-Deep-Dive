# 함수

함수란 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행단위로 정의한 것이다.

- 함수는 [함수 정의](#함수정의)를 통해 생성한다.
- 함수에 인수를 전달하고, 함수의 실행을 지시함으로써 함수를 호출한다.

## 함수 리터럴

자바스크립트의 함수는 객체타입의 값이다. 숫자 값을 숫자리터럴로 생성하고, 객체를 객체리터럴로 생성하듯이 함수도 **함수리터럴**로 생성할 수 있다.

```javascript
let f = funciton add(x,y){
  return x+y
}
```

위 코드는 함수리터럴을 변수에 할당한다. (리터럴은 사람이 이해할수 있는 문자, 기호를 사용해 값을 생성하는 표기방식이라 배웠다.) 즉, 리터럴은 값을 생성하기 위한 표기법이므로, 함수 리터럴도 평가되어 '값'을 생성하며 이값은 **객체**다

> 👉 함수는 호출할 수 있는 객체다.

#### 함수리터럴의 구성요소

| 구성요소 | 설명                                                                                                                                               |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| 함수이름 | - 함수이름은 **함수 몸체 내부**에서만 참조할 수 있는 식별자다.<br /> - 함수이름은 생략가능하다. 이름있는 함수(기명함수), 이름없는 함수(무기명함수) |
| 매개변수 | 매개변수는 함수 몸체 내부에서 변수와 동일취급되므로 식별자 네이밍규칙을 준수해야 한다.                                                             |
| 함수몸체 | 함수가 호출될때 실행한 문을 하나의 실행단위로 정의한 코드블록 <br /> 함수 호출에 의해 실행된다.                                                    |

## 함수정의

함수정의방법에는 4가지가 있다.

1. 함수 선언문

```javascript
function add(a, b) {
  return a + b
}
```

2. 함수 표현식

```javascript
let add = function (a, b) {
  return a + b
}
```

3. Function 생성자 함수

```javascript
let add = new Function('a', 'b', 'return a+b')
```

4. 화살표함수(ES6)

```javascript
let add = (a, b) => a + b
```

### 1. 함수 선언문

함수선언문은 함수 리터럴과 형태가 동일하나, 함수이름을 생략할 수 없다.

> 함수 선언문은 **표현식이 아닌 문**이다.

**확인하기🤨**
크롬 개발자 도구의 콘솔에서 함수선언문을 실행하면 완료값(undefined)가 출련되므로..(표현식인 문이라면 완료값대신 표현식이 평가되어 생성된 함수가 출력되어야 한다.) -> 5장에서 완료값에 대해 다루었다.

그런데 이미 배운것처럼 "표현식이 아닌 문"은 변수에 할당 될 수 없다.

```javascript
let add = function add(x, y) {
  return x + y
}
```

그런데 이 코드는 함수선언문이 마치 변수에 할당될 수 잇는 것 처럼 보인다.
이 괴리감은 어떻게 설명될까?

💡 Javascript 엔진이 코드 문맥에 따라 함수리터럴을 `함수선언문(표현식❌)`으로 해석하는 경우와 `함수리터럴표현식(표현식⭕️)`으로 해석하는 경우가 있기 때문이다.<br />
Javascript 엔진은 이름이 있는 함수 리터럴를 만났을 때,

- 단독으로 사용하는 경우(피연산자로 사용하지 않는 경우)에는 `함수 선언문`으로 해석한다.
- 값으로 평가 되어야 될때 (1. 변수에 할당, 2.피연산자로 사용됨)에는 `함수 리터럴 표현식`으로 해석한다.

👉 둘다 함수가 생성되는 것은 동일하나, 함수를 생성하는 내부 동작에는 차이가 있다.

```javascript
function foo() {
  console.log('foo~~')
}
foo() // 'foo~~'
```

이렇게 기명함수리터럴을 단독으로 사용하면 `함수 선언문`으로 해석된다.

```javascript
;(function bar() {
  console.log('bar~~')
})
bar() // 🚨Reference Error : bar is not defined
//함수 리터럴 표현식으로 해석되면 호출할 수 없다.
```

그룹연산자`()`내부에 있는 함수리터럴은 `함수 리터럴 표현식`으로 해석된다.
(연산자 내부의 피연산자는 표현식이여야 하기 때문)
함수 리터럴 표현식으로 해석되면 호출할 수 없다! 왜 그럴까?

[함수리터럴의 구성요소 중 함수이름](#함수리터럴의-구성요소)에서 **함수이름은 함수 내부에서만 참조할 수 있는 식별자**라고 했다.

> 즉, 함수 외부에서는 함수를 참조할 수 없다 = 함수 외부에서 함수를 호출 할 수 없다.

함수를 가리키는 식별자가 없으므로 bar함수는 호출 할 수 없다.

foo함수는 함수 몸체 외부에서 호출 할 수 있었다.
그 이유는 javascript엔진이 함수선언문을 해석해 함수객체를 생성하는데,
이 생성된 함수를 호출하기 위해 함수이름과 동일한 식별자를 암묵적으로 생성하고 거기에 함수객체를 할당한다.

#### 함수선언문의 호이스팅

```javascript
console.dir(add) // f add(x,y)
console.log(add(1, 2)) // 7

function add(x, y) {
  return x + y
}
```

> 함수 선언문으로 정의한 함수는 선언 이전에 호출할 수 있다.

런타임 이전에 JS엔진에 의해 먼저 실행된다. (런타임 이전에 함수객체가 먼저 생성) 그리고 함수이름과 동일한 식별자를 암묵적으로 생성하고 함수객체를 할당한다.
그래서 런타임에는 이미 함수객체가 생성되어 있고, 이미 식별자에 할당까지 완료된 상태이므로 함수 선언문 이전에 참조, 호출이 가능하다.

> 함수 선언문이 코드의 선두로 끌어 올려진것처럼 동작하는 특징을 함수 호이스팅이라고 한다.

### 2. 함수 표현식

javascript의 함수는 객체타입의 값으로, 변수에 할당, 프로퍼티의 값, 배열의 요소가 될 수 있다. 👉 이러한 성질을 갖는 객체를 일급객체라 한다.

함수리터럴의 이름은 생략가능하다.(일반적으로 생략, 익명함수)

```javascript
let add = function foo(a, b) {
  return a + b
}

console.log(add(2, 5)) //7
console.log(foo(2.5)) //🚨reference error
```

foo는 함수내부에서만 유효한 식별자이므로 함수를 호출할 수 없다.
함수를 호출하려면 함수이름이 아니라 **함수객체를 가리키는 식별자**를 사용한다.

```javascript
console.dir(sub) //undefined
console.log(sub(2, 5)) // Type error, sub is not a function

let sub = function (x, y) {
  return x - y
}
```

함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 따라서 변수의 선언과 할당과 동일하게 동작한다.

변수 선언 : 런타임 이전 실행되어 Undefined로 초기화됨  
변수 할당: 런타임에 평가되어 할당됨

마찬가지로 함수리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
👉 함수 표현식으로 함수를 정의하면 함수호이스팅이 아니라 변수 호이스팅이 발생

> ## ✅ 정리
>
> ### 함수 선언문
>
> - 함수 리터럴은 이름을 생략할 수 있으나 함수 선언문은 생략할 수 없다.
> - 함수 선언문은 문이지만 표현식은 아니다.
> - 런타임 전 함수 호이스팅으로 선언과 동시에 함수 객체를 생성한다.
> - js엔진이 암묵적으로 함수 이름을 식별자로 생성한다.
>
> ### 함수 표현식
>
> - js의 함수는 값처럼 변수에 할당, 프로퍼티의 값, 배열의 요소가 될 수 있다.(일급 객체)
> - 리터럴의 함수 이름은 생략할 수 있다.(익명 함수)
> - 표현식은 함수 호이스팅이 아닌 변수 호이스팅의 영향을 받기 때문에 함수 객체가 런타임 전에 생성되지는 않는다.

### 3. Function 생성자 함수

```javascript
let add = new Function('x', 'y', 'return x+y')
console.log(add(2, 5)) //7
```

- Function 생성자 함수로 함수를 생성하는 것은 지양하자
- 클로저를 생성하지 않는다. (함수선언문, 함수 표현식으로 만든 함수와 다르게 동작)

### 4. 화살표 함수(ES6)

```javascript
const add = (x, y) => x + y
console.log(add(2, 5)) //7
```

- 화살표함수는 기존의 함수보다 표현뿐 아니라 **내부동작**도 간략화되어있음
- 생성자 함수로 사용할 수 없다
- 기존의 함수의 this바인딩 방식이 다르다
- Prototype프로퍼티가 없다.
- argument객체를 생성하지 않는다.

### Javascript 함수의 특징

- 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.(할당되지 않으면 Undefined)
- 인수의 갯수 > 매개변수의 갯수 이면, 초과된 인수는 무시된다.(arument객체에 저장
  )
- 매개변수 갯수는 3개 이하가 적당, 그 이상이라면 객체로 전달하자.

### 즉시실행함수(IIFE)

- 즉시실행함수는 정의되자 마자 실행된다.
- 즉시실행함수는 단한번만 호출되며 다시 호출할 수 없다.
- 그룹연산자`()`를 이용해 감싸야 한다.

```javascript
;(function () {
  let a = 3
  let b = 4
  return a * b
})()
```

### 콜백함수

**콜백 함수**

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

**고차 함수**

- 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수
- 전달받은 콜백함수의 호출시점을 결정한다.
- 고차함수는 콜백함수를 자신의 일부분으로 합성한다.

```javascript
//어떤 일을 n번 반복하는 함수
function repeat(n) {
  for (let i = 0; i < n; i++) {
    console.log(i)
  }
}

//어떤 일을 N번 반복하는 함수
function repeatOdd(n) {
  for (let i = 0; i < n; i++) {
    if (i % 2) console.log(i) //홀수 일때만 출력
  }
}

//위 함수들은 반복하는 일은 동일, 일의 내용은 다르다
//-> 공통로직은 미리 정의해두고
//-> 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달한다.

function repeat(n, f) {
  //전달받은 함수 f를 n번 반복한다.
  for (let i = 0; i < n; i++) {
    f(i)
  }
}

const logAll = function (i) {
  console.log(i)
}
const logOdd = function (i) {
  if (i % 2) console.log(i)
}

// 모두 출력
repeat(5, logAll)
// 홀수번만 출력
repeat(5, logOdd)
```

### 순수함수 & 비순수함수

**순수함수**

- 외부상태에 의존하지 않고, 외부상태를 변경하지 않는 함수
- 부수효과가 없는 함수
- 동일한 인수 -> 동일한 반환값

```javascript
let count = 0
function increase(a) {
  return ++a
}
```

**비순수함수**

- 외부상태에 의존하고, 외부상태를 변경하는 함수
- 부수효과가 있는 함수
- 외부상태를 변경하므로 상태변화 추적이 어려워진다.

```javascript
let count = 0
function increase() {
  return ++count
}
```
