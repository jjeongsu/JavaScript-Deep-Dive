# let, const키워드와 블록레벨 스코프

## var 키워드(로 선언한 변수)의 문제점

1. 변수의 재선언이 가능하다.
2. 함수레벨 스코프만 지역으로 인정한다.

- if, for문과 같은 블록내에서 var변수를 바꿀경우 전역에서 변경되는 문제가 발생한다.

3. 변수 호이스팅으로 선언하기 이전에 참조할 수 있다.

- Undefined로 뜨긴 하지만 에러를 발생시키지 않는다.

## let

1. 재선언 금지, 재할당 가능
2. 블록 레벨 스코프

- 모든 코드블록(함수, If, for, while, try/catch)를 지역 스코프로 인정한다.

3. 변수 호이스팅이 발생하지 않는 것처럼 동작(but 실제로는 호이스팅이 일어남)

- var로 선언한 변수는 런타임이전에 선언단계, 초기화 단계가 한번에 진행된다.

```javascript
// * 이때 선언과 초기화가 이루어진다. : 메모리에 변수 이름을 등록하고 저장할 메모리 공간을 확보, Undefined가 할당된다. 이것은 런타임 이전에 이루어진다.

console.log(foo); // -> undefined

var foo; // 선언문
console.log(foo); // -> undefined

foo = 1; // 할당 : 런타임에 이루어진다.
console.log(foo); // -> 1
```

- let으로 선언한 변수는 선언단계과 초기화 단계가 분리되어 진행된다.

```javascript
// * 런타임 이전일때 선언이 이루어진다. 초기화는 이루어 지지 않는다.

console.log(foo); // -> 참조 에러 : 초기화 이후 참조가 가능하다.

let foo; // 초기화
console.log(foo); // undefined

foo = 1; // 할당
console.log(foo); // 1
```

4.let으로 선언하면 전역객체의 프로퍼티가 아니며 개념적 블록내에 존재함.  
let 전역변수는 전역 객체의 프로퍼티가 아니다. let 전역변수는 전역 렉시컬 환경의 선언적 환경 레코드내에 존재하게 된다.

## const

0. 재할당, 재선언 금지
1. 선언과 초기화를 동시에 해야 한다. (✅ let과의 차이점)

```javascript
const no; // 🚨syntax error
const a = 1 // ✅
```

2. 블록 레벨 스코프를 가진다.
3. 변수 호이스팅이 발생하지 않는 것처럼 동작(but 실제로는 호이스팅이 일어남)

정리

- Var의 사용을 피하자
- 재할당이 필요한 경우 let을 사용하고, 변수의 스코프는 최대한 좁게 만들자.
- 읽기전용에는 const를 사용한다.
